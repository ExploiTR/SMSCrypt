package app.exploitr.sec.scrypt.security;

import android.content.Context;
import android.content.pm.PackageManager;
import android.security.keystore.KeyGenParameterSpec;
import android.security.keystore.KeyProperties;

import com.google.crypto.tink.aead.subtle.AesGcmSiv;
import com.google.crypto.tink.subtle.Hkdf;

import java.io.ByteArrayOutputStream;
import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.spec.ECGenParameterSpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Arrays;
import java.util.Base64;

import javax.crypto.KeyAgreement;

import app.exploitr.sec.scrypt.utils.Core;

public class ECCUtil {
    //--------------------------------------------------------------------------------------------------------------124-----------160---------212----
    //-----------------------------------------------0-------1--------2--------3-----------4------------5------------6------------7------------8------
    private static final String[] EC_SPEC_LIST = {"p-224", "p-256", "p-384", "p-521", "prime256v1", "secp224r1", "secp256r1", "secp384r1", "secp521r1"};

    private static final String EC_SPEC = EC_SPEC_LIST[7];
    private static final String MAC_ALG = "HMACSHA256";
    private static final String INFO_TAG = "ECDH " + EC_SPEC + " AES-256-GCM-SIV\0";
    private static final String KEY_AGREEMENT_ALG = "ECDH";
    private static final String KEY_STORE_PROVIDER = "AndroidKeyStore";

    public static boolean hasStrongBox(Context mActivity) {
        return mActivity.getPackageManager()
                .hasSystemFeature(PackageManager.FEATURE_STRONGBOX_KEYSTORE);
    }

    public static void clearPairs(String[] pairs) throws Exception {
        KeyStore keyStore = KeyStore.getInstance(KEY_STORE_PROVIDER);
        keyStore.load(null);
        Arrays.stream(pairs).spliterator().forEachRemaining(any -> {
            try {
                if (keyStore.containsAlias(any))
                    keyStore.deleteEntry(any);
            } catch (KeyStoreException e) {
                e.printStackTrace();
            }
        });
    }

    public static KeyPair getKeysFromStore(String KEY_PAIR_NAME) throws Exception {
        KeyStore keyStore = KeyStore.getInstance(KEY_STORE_PROVIDER);
        keyStore.load(null);
        KeyStore.Entry entry = keyStore.getEntry(KEY_PAIR_NAME, null);
        PrivateKey privateKey = ((KeyStore.PrivateKeyEntry) entry).getPrivateKey();
        PublicKey publicKey = keyStore.getCertificate(KEY_PAIR_NAME).getPublicKey();
        return new KeyPair(publicKey, privateKey);
    }

    public static KeyPair generateKeys(String KEY_PAIR_NAME) throws Exception {
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(
                KeyProperties.KEY_ALGORITHM_EC, KEY_STORE_PROVIDER);
        keyPairGenerator.initialize(
                new KeyGenParameterSpec.Builder(
                        KEY_PAIR_NAME,
                        KeyProperties.PURPOSE_AGREE_KEY)
                        .setAlgorithmParameterSpec(new ECGenParameterSpec(EC_SPEC))
                        .setIsStrongBoxBacked(true)
                        .build());
        return keyPairGenerator.generateKeyPair();
    }

    public static byte[] sharedSecret(PrivateKey mine, PublicKey remote) throws Exception {
        KeyAgreement keyAgreement = KeyAgreement.getInstance(KEY_AGREEMENT_ALG, KEY_STORE_PROVIDER);
        keyAgreement.init(mine);
        keyAgreement.doPhase(remote, true);
        return keyAgreement.generateSecret();
    }

    public static byte[][] generateSaltAndInfo(PublicKey mine, PublicKey remote) throws Exception {
        byte[] temp_sal = Core.MASTER_PASSWORD.get().getBytes();
        byte[] SALT = new byte[16];
        System.arraycopy(temp_sal, 0, SALT, 0, 16);

        ByteArrayOutputStream info = new ByteArrayOutputStream();
        info.write(INFO_TAG.getBytes(StandardCharsets.UTF_8));
        info.write(mine.getEncoded());
        info.write(remote.getEncoded());

        byte[][] temp = new byte[2][];
        temp[0] = SALT;
        temp[1] = info.toByteArray();
        return temp;
    }

    public static AesGcmSiv exchangeKey(byte[] sharedSecret, byte[] salt, byte[] info) throws Exception {
        return new AesGcmSiv(Hkdf.computeHkdf(
                MAC_ALG, sharedSecret, salt, info, 32));
    }

    public static String publicToString(PublicKey key) {
        return Base64.getEncoder().encodeToString(key.getEncoded());
    }

    public static PublicKey stringToPublic(String key) throws Exception {
        return KeyFactory.getInstance("EC").generatePublic(new X509EncodedKeySpec(Base64.getDecoder().decode(key)));
    }
}
