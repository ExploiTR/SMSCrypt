package app.exploitr.sec.scrypt.ui.general;

import android.app.KeyguardManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.hardware.biometrics.BiometricManager;
import android.hardware.biometrics.BiometricPrompt;
import android.os.Bundle;
import android.os.CancellationSignal;
import android.telephony.TelephonyManager;
import android.text.Editable;
import android.view.View;
import android.widget.Toast;

import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.IntentSenderRequest;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.annotation.NonNull;
import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.content.ContextCompat;

import com.google.android.gms.auth.api.Auth;
import com.google.android.gms.auth.api.credentials.Credential;
import com.google.android.gms.auth.api.credentials.HintRequest;
import com.google.android.gms.auth.api.identity.GetPhoneNumberHintIntentRequest;
import com.google.android.gms.auth.api.identity.Identity;
import com.google.android.gms.common.api.GoogleApiClient;
import com.google.android.gms.tasks.OnFailureListener;

import java.security.GeneralSecurityException;

import app.exploitr.sec.scrypt.database.LocalDatabase;
import app.exploitr.sec.scrypt.databinding.ActivityWelcomeBinding;
import app.exploitr.sec.scrypt.databinding.MasterPwdReinBinding;
import app.exploitr.sec.scrypt.utils.Core;
import app.exploitr.sec.scrypt.utils.Iso2Phone;

public class Welcome extends AppCompatActivity {

    private KeyguardManager keyguardManager;
    private ActivityWelcomeBinding binding;

    ActivityResultLauncher<IntentSenderRequest> phoneNumberHintIntentResultLauncher =
            registerForActivityResult(
                    new ActivityResultContracts.StartIntentSenderForResult(), result -> {
                        try {
                            String phoneNumber = Identity.getSignInClient(getApplicationContext()).getPhoneNumberFromIntent(result.getData());
                            if (binding != null)
                                binding.phoneInput.setText(phoneNumber);
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    });

    @SuppressWarnings("deprecation")
    ActivityResultLauncher<IntentSenderRequest> phoneNumberHintIntentResultLauncherLegacy =
            registerForActivityResult(
                    new ActivityResultContracts.StartIntentSenderForResult(), result -> {
                        try {
                            Credential cred;
                            if (result.getData() != null) {
                                cred = result.getData().getParcelableExtra(Credential.EXTRA_KEY);
                                if (binding != null)
                                    binding.phoneInput.setText(cred.getId());
                            }
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    });

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        binding = ActivityWelcomeBinding.inflate(getLayoutInflater());
        setContentView(binding.getRoot());

        keyguardManager = (KeyguardManager) getApplicationContext().getSystemService(Context.KEYGUARD_SERVICE);

        if (secureDevice()) {
            set_up();
            //todo move forward
        } else {
            Toast.makeText(this, "Please enable screen lock to use the application.", Toast.LENGTH_LONG).show();
            finishAndRemoveTask();
        }
    }

    private void set_up() {
        var biometric = new BiometricPrompt.Builder(this)
                .setConfirmationRequired(true)
                .setAllowedAuthenticators(BiometricManager.Authenticators.BIOMETRIC_STRONG | BiometricManager.Authenticators.DEVICE_CREDENTIAL)
                .setTitle("Confirm Device Lock")
                .setSubtitle("Please prove device ownership.")
                .build();

        var authCallback = new BiometricPrompt.AuthenticationCallback() {
            @Override
            public void onAuthenticationError(int errorCode, CharSequence errString) {
                if (isACaseOf(errorCode, BiometricPrompt.BIOMETRIC_ERROR_HW_UNAVAILABLE, BiometricPrompt.BIOMETRIC_ERROR_HW_NOT_PRESENT,
                        BiometricPrompt.BIOMETRIC_ERROR_CANCELED, BiometricPrompt.BIOMETRIC_ERROR_USER_CANCELED, BiometricPrompt.BIOMETRIC_ERROR_VENDOR
                        , BiometricPrompt.BIOMETRIC_ERROR_LOCKOUT_PERMANENT)) {
                    Toast.makeText(Welcome.this, "Can't work without biometrics!", Toast.LENGTH_LONG).show();
                    finishAndRemoveTask();
                } else if (errorCode == BiometricPrompt.BIOMETRIC_ERROR_NO_BIOMETRICS) {
                    Toast.makeText(Welcome.this, "Please setup biometric in settings!", Toast.LENGTH_LONG).show();
                    finishAndRemoveTask();
                } else if (errorCode == BiometricPrompt.BIOMETRIC_ERROR_SECURITY_UPDATE_REQUIRED) {
                    Toast.makeText(Welcome.this, "Missing Security Patch! Please update the OS.", Toast.LENGTH_LONG).show();
                    finishAndRemoveTask();
                } else if (isACaseOf(errorCode, BiometricPrompt.BIOMETRIC_ERROR_LOCKOUT
                        , BiometricPrompt.BIOMETRIC_ERROR_TIMEOUT, BiometricPrompt.BIOMETRIC_ERROR_UNABLE_TO_PROCESS)) {
                    Toast.makeText(Welcome.this, "Biometric temporarily blocked, retry after sometime , Code: " + errorCode, Toast.LENGTH_SHORT).show();
                    finishAndRemoveTask();
                } else {
                    Toast.makeText(Welcome.this, "Error : Biometric is disabled | Code : " + errorCode, Toast.LENGTH_SHORT).show();
                    finishAndRemoveTask();
                }
                super.onAuthenticationError(errorCode, errString);
            }

            @Override
            public void onAuthenticationHelp(int helpCode, CharSequence helpString) {
                Toast.makeText(Welcome.this, helpString, Toast.LENGTH_SHORT).show();
                super.onAuthenticationHelp(helpCode, helpString);
            }

            @Override
            public void onAuthenticationSucceeded(BiometricPrompt.AuthenticationResult result) {
                moveForward();
                super.onAuthenticationSucceeded(result);
            }

            @Override
            public void onAuthenticationFailed() {
                Toast.makeText(Welcome.this, "Couldn't verify screen lock, try again?", Toast.LENGTH_SHORT).show();
                binding.retryAuth.setVisibility(View.VISIBLE);
                binding.loadingWelcome.setVisibility(View.INVISIBLE);
                binding.aliasLayout.setVisibility(View.INVISIBLE);
                binding.phoneLayout.setVisibility(View.INVISIBLE);
                binding.signUpAnim.setVisibility(View.INVISIBLE);
                binding.masterPassLayout.setVisibility(View.INVISIBLE);
                binding.continueNext.setVisibility(View.INVISIBLE);
                binding.pwdWarn.setVisibility(View.INVISIBLE);
                super.onAuthenticationFailed();
            }
        };

        var cal = new CancellationSignal();
        cal.setOnCancelListener(() -> {
            Toast.makeText(Welcome.this, "Authentication cancelled!", Toast.LENGTH_SHORT).show();
            binding.retryAuth.setVisibility(View.VISIBLE);
            binding.retryAuth.setOnClickListener(v -> biometric.authenticate(cal, ContextCompat.getMainExecutor(Welcome.this), authCallback));
        });

        if (Core.ENABLE_TEST_MODE) {
            startActivity(new Intent(Welcome.this, MainActivity.class));
            Welcome.this.finish();
        } else {
            biometric.authenticate(cal, ContextCompat.getMainExecutor(this), authCallback);
        }

        binding.retryAuth.setOnClickListener(v -> {
            binding.loadingWelcome.setVisibility(View.VISIBLE);
            Toast.makeText(this, "TODO", Toast.LENGTH_SHORT).show();
            biometric.authenticate(cal, ContextCompat.getMainExecutor(this), authCallback);
        });

        binding.phoneInput.setOnFocusChangeListener((view, b) -> {
            if (b) {
                showPhoneNumberOptions();
            }
        });
    }

    private boolean isACaseOf(int code, int... list_of_codes) {
        for (int any : list_of_codes) {
            if (any == code) {
                return true;
            }
        }
        return false;
    }

    private void showPhoneNumberOptions() {
        GetPhoneNumberHintIntentRequest request = GetPhoneNumberHintIntentRequest.builder().build();

        Identity.getSignInClient(this)
                .getPhoneNumberHintIntent(request)
                .addOnSuccessListener(result -> {
                    try {
                        phoneNumberHintIntentResultLauncher.launch(new IntentSenderRequest.Builder(result.getIntentSender()).build());
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                })
                .addOnFailureListener(new OnFailureListener() {
                    @Override
                    public void onFailure(@NonNull Exception e) {
                        e.printStackTrace();
                        //try legacy mode
                        showPhoneNumberOptionsLegacy();
                    }
                });
    }

    @SuppressWarnings("deprecation")
    private void showPhoneNumberOptionsLegacy() {
        var googleApiClient = new GoogleApiClient.Builder(this)
                .addApi(Auth.CREDENTIALS_API)
                .build();
        HintRequest hintRequest = new HintRequest.Builder()
                .setPhoneNumberIdentifierSupported(true)
                .build();

        PendingIntent intent = Auth.CredentialsApi.getHintPickerIntent(googleApiClient, hintRequest);
        phoneNumberHintIntentResultLauncherLegacy.launch(new IntentSenderRequest.Builder(intent.getIntentSender()).build());
    }

    private void moveForward() {
        LocalDatabase da = LocalDatabase.getInstance(getBaseContext());

        if (da.getPhone() != null && !da.getPhone().isEmpty()) {
            startActivity(new Intent(Welcome.this, MainActivity.class));
            Welcome.this.finish();
            return;
        }

        binding.retryAuth.setVisibility(View.INVISIBLE);
        binding.loadingWelcome.setVisibility(View.INVISIBLE);
        binding.aliasLayout.setVisibility(View.VISIBLE);
        binding.phoneLayout.setVisibility(View.VISIBLE);
        binding.signUpAnim.setVisibility(View.VISIBLE);
        binding.masterPassLayout.setVisibility(View.VISIBLE);
        binding.continueNext.setVisibility(View.VISIBLE);
        binding.pwdWarn.setVisibility(View.VISIBLE);

        TelephonyManager telephonyManager = (TelephonyManager) this.getSystemService(Context.TELEPHONY_SERVICE);
        if (telephonyManager != null) {
            binding.phoneInput.setText(Iso2Phone.getPhone(telephonyManager.getNetworkCountryIso()));
        }

        binding.aliasInput.setText("");

        binding.continueNext.setOnClickListener(v -> {
            Editable elo;
            Editable geo;
            Editable neo;

            boolean clear = true;

            elo = binding.aliasInput.getText();
            if ((elo) != null && elo.length() >= 3) {
                da.setAlias(elo.toString());
            } else {
                binding.aliasLayout.setError("Too short alias name!");
                clear = false;
            }

            geo = binding.phoneInput.getText();
            if ((geo) != null && geo.length() >= 6) {
                da.setPhone(geo.toString());
            } else {
                binding.phoneLayout.setError("Invalid phone number!");
                clear = false;
            }

            neo = binding.masterPassInput.getText();
            if ((neo) != null && neo.length() >= 4 && clear) {
                try {
                    da.setMasterPasswordEncryptedText(neo.toString());
                    testIfUserCanRecallMasterPwd(da);
                } catch (GeneralSecurityException e) {
                    binding.masterPassLayout.setError("Unknown error occurred while testing encryption!");
                    e.printStackTrace();
                }
            } else {
                binding.masterPassLayout.setError("Too short encryption key!");
            }
        });
    }

    private void testIfUserCanRecallMasterPwd(LocalDatabase da) {
        AlertDialog alertDialog = createDialogue(da);
        if (!this.isFinishing())
            alertDialog.show();
    }

    private AlertDialog createDialogue(LocalDatabase da) {
        MasterPwdReinBinding binding = MasterPwdReinBinding.inflate(getLayoutInflater());

        binding.masterPwdReinReason.setText("Re-enter Master Password");

        AlertDialog dialog = new AlertDialog.Builder(Welcome.this)
                .setView(binding.getRoot())
                .setCancelable(false)
                .setNegativeButton("Retry", null)
                .setPositiveButton("Verify", null)
                .setTitle("Enter Master Password")
                .create();

        dialog.setOnShowListener(dialog_ -> {
            dialog.getButton(AlertDialog.BUTTON_POSITIVE)
                    .setOnClickListener(v -> {
                        try {
                            Editable pass = null;
                            if (((pass = binding.masterPwdReinInput.getText()) != null) && da.getMasterPasswordVerificationTestSuccess(pass.toString())) {
                                binding.masterPwdReinInput.setText("");
                                dialog_.dismiss();
                                moveForward();
                            } else {
                                binding.masterPwdReinLayout.setError("Wrong encryption key!");
                            }
                        } catch (GeneralSecurityException e) {
                            binding.masterPwdReinLayout.setError("Wrong encryption key!");
                            e.printStackTrace();
                        }
                    });

            dialog.getButton(DialogInterface.BUTTON_NEGATIVE).setOnClickListener(v -> {
                dialog.dismiss();
                try {
                    da.setMasterPasswordEncryptedText("");
                } catch (GeneralSecurityException e) {
                    e.printStackTrace();
                }
            });
        });

        return dialog;
    }


    private boolean secureDevice() {
        return keyguardManager.isDeviceSecure() && keyguardManager.isKeyguardSecure();
    }
}