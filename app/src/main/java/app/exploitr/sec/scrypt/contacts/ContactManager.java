package app.exploitr.sec.scrypt.contacts;

import static contacts.core.ContactsKt.Contacts;
import static contacts.core.OrderByKt.asc;

import android.content.Context;
import android.os.Handler;
import android.os.Looper;

import androidx.annotation.Nullable;

import com.google.i18n.phonenumbers.NumberParseException;
import com.google.i18n.phonenumbers.PhoneNumberUtil;
import com.google.i18n.phonenumbers.Phonenumber;

import java.util.HashMap;
import java.util.List;
import java.util.Spliterator;

import contacts.core.ContactsFields;
import contacts.core.entities.Contact;

public class ContactManager {
    private static HashMap<String, Contact> contactMap;

    /*
     * Run this only once.
     * Creates a local model for search efficiency
     * */
    public static void mapOrUpdateContacts(Context context, ContactMappingListener listener) {
        var tempMap = new HashMap<String, Contact>();
        getAllContactsArray(context, contacts -> {
            for (var contact : contacts) {
                if (contact != null) {
                    var rawContacts = contact.getRawContacts();
                    if (rawContacts.size() > 0)
                        for (var rawContact : rawContacts) {
                            var phones = rawContact.getPhones();
                            if (phones.size() > 0)
                                for (var phone : phones)
                                    tempMap.put(phone.getNormalizedNumber(), contact);
                        }
                }
            }
            /* I know this is unnecessary but it has been done at the cost of some extra memory
             * to ensure that contactMap stays null until it's finally updated so error is thrown
             * in case someone tries to access it from a different thread while it's being updated*/
            contactMap = new HashMap<>();
            contactMap.putAll(tempMap);
            /* read */
            listener.onMapComplete();
        });
    }

    /*
     * Info : query is auto-formatted to E164
     * */
    @Nullable
    public static Contact searchContactE164(String contact) {
        if (contactMap == null)
            throw new RuntimeException("Contacts aren't mapped! run ContactManager.mapOrUpdateContacts(...) first.");
        PhoneNumberUtil util = PhoneNumberUtil.getInstance();
        Phonenumber.PhoneNumber pNum = null;
        try {
            pNum = util.parse(contact, null);
        } catch (NumberParseException e) {
          //  e.printStackTrace();
        }
        if (pNum != null) {
            contact = util.format(pNum, PhoneNumberUtil.PhoneNumberFormat.E164);
        }
        return contactMap.get(contact);
    }

    public static void getAllContactsArray(Context context, ContactArrayLoadingListener listener) {
        new Thread(() -> {
            var contacts = Contacts(context)
                    .query()
                    .orderBy(asc(ContactsFields.DisplayNamePrimary))
                    .find();
            new Handler(Looper.getMainLooper()).post(() -> listener.onLoadComplete(contacts));
        }).start();
    }

    public static Spliterator<Contact> getAllContactsIterator(Context context) {
        return Contacts(context).query().find().spliterator();
    }

    public static void searchContacts(Context context, String query, ContactArrayLoadingListener listener) {
        new Thread(() -> {
            var contacts = Contacts(context).broadQuery().wherePartiallyMatches(query).find();
            new Handler(Looper.getMainLooper()).post(() -> listener.onLoadComplete(contacts));
        }).start();
    }

    public interface ContactArrayLoadingListener {
        void onLoadComplete(List<Contact> contacts);
    }

    public interface ContactMappingListener {
        void onMapComplete();
    }
}
