package app.exploitr.sec.scrypt.pairing;

import android.content.Context;

import androidx.annotation.NonNull;

import com.google.crypto.tink.aead.subtle.AesGcmSiv;

import java.nio.charset.StandardCharsets;
import java.security.KeyPair;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.util.Base64;

import app.exploitr.sec.scrypt.messages.SMSRecordManager;
import app.exploitr.sec.scrypt.security.ECCUtil;
import contacts.core.entities.Contact;

public class PairingManager {
    /*
     * Authentication Stages
     * Initiator :
     * 1 -- Create keys & Send initial pairing request with p_key
     * 2 -- Receive pb key , generate salt & create shared acs then Send ack
     * 3 -- Receive ack & check ack
     * Receiver:
     * 1 -- Receive pb key then Generate key and send public key
     *
     * Key format :
     *
     * pub:key
     * pub:122 bit ort pub:160 bit
     *
     * */

    private static final String PAIR_MESSAGE_INIT = "pub:%s";
    public static final int PAIRING_MODE_REQUEST = 0;
    public static final int PAIRING_MODE_ACCEPT = 1;

    public static void start(long id, String contact, int mode) {
        if (mode == PAIRING_MODE_REQUEST)
            doLevelsRequest(id, contact);
        else if (mode == PAIRING_MODE_ACCEPT)
            doLevelsReceive(contact);
        System.out.println(contact);
    }

    private static void doLevelsReceive(String contact) {

    }

    private static void level2_receive(String message, String against, Contact contact, int rawContactIndex, int phoneIndex, Context context) throws Exception {

        updateLevel(contact.getId(), 5);
    }

    private static void level1_receive(String message, String against, Contact contact, int rawContactIndex, int phoneIndex, Context context) throws Exception {
        PublicKey remote = ECCUtil.stringToPublic(message.split("pub:")[1]);
        KeyPair pair = ECCUtil.generateKeys(String.valueOf(contact.getId()));
        SMSRecordManager.sendMessage(contact.getRawContacts().get(rawContactIndex).getPhones().get(phoneIndex).getNumber(),
                ECCUtil.publicToString(pair.getPublic()));
        ECCUtil.sharedSecret(pair.getPrivate(), remote);
        ECCUtil.generateSaltAndInfo(pair.getPublic(), remote);
        updateLevel(contact.getId(), 4);
    }

    public static void doLevelsRequest(long id, String contact) {
        //get level (level select)
        try {
            sendPairingRequest(contact, id);
            receiveRemotePublicAndSend_ACK("todo", contact, id);//todo todo todo
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void level3_request(String message, String against, Contact contact, int rawContactIndex, int phoneIndex, Context context) {

    }

    private static void receiveRemotePublicAndSend_ACK(@NonNull String message, String contact, long contact_id) throws Exception {
        KeyPair mine = ECCUtil.getKeysFromStore(String.valueOf(contact_id));
        PublicKey remote = ECCUtil.stringToPublic(message.split("pub:")[1]);

        var salt_info = ECCUtil.generateSaltAndInfo(mine.getPublic(), remote);
        AesGcmSiv final_key = ECCUtil.exchangeKey(ECCUtil.sharedSecret(mine.getPrivate(), remote), salt_info[0], salt_info[1]);

        String[] ack = generateAck();
        String true_ack = Base64.getEncoder().encodeToString(final_key.encrypt(ack[0].getBytes(StandardCharsets.UTF_8), generateAEAD()));
        SMSRecordManager.sendMessage(contact, true_ack);
        updateLevel(contact_id, 2);
    }

    private static void sendPairingRequest(String contact, long id) throws Exception {
        var pair = ECCUtil.generateKeys(String.valueOf(id));
        sendPairingInitiationMessage(contact, pair.getPublic());
        updateLevel(id, 1);
    }

    private static void updateLevel(long id, int level) {

    }

    private static byte[] generateAEAD() {
        SecureRandom random = new SecureRandom();
        return String.valueOf(random.nextInt(1000) * random.nextInt(5) * 5).getBytes(StandardCharsets.UTF_8);
    }

    private static String[] generateAck() {
        SecureRandom random = new SecureRandom();
        int num1 = random.nextInt(Integer.MAX_VALUE / 2);
        int num2 = random.nextInt(Integer.MAX_VALUE / 2);
        String[] stuff = new String[2];
        stuff[0] = num1 + "+" + num2;
        stuff[1] = String.valueOf(num1 + num2);
        return stuff;
    }


    public static void sendPairingInitiationMessage(String number, PublicKey mine) {
        SMSRecordManager.sendMessage(number, String.format(PAIR_MESSAGE_INIT, ECCUtil.publicToString(mine)));
    }

    public static void waitForPairingInitiationAck(PairingListener listener) {
        //onReceiveStuff todo
    }

    public static void delete(Contact contact) {
        //todo
    }

    public interface PairingListener {
        void onLevelCompleted(int level);

        void onFailure(String reason);
    }

}
