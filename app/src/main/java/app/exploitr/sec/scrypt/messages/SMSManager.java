package app.exploitr.sec.scrypt.messages;

import android.content.Context;
import android.database.Cursor;
import android.net.Uri;
import android.os.Handler;
import android.os.Looper;
import android.provider.Telephony;

import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;

import javax.annotation.Nullable;

import app.exploitr.sec.scrypt.models.SMSModel;
import app.exploitr.sec.scrypt.models.ThreadModel;

public class SMSManager {
    final static String SMS_URI_INBOX = "content://sms";
    final static Uri URI_THREADS = Telephony.Threads.CONTENT_URI;

    final static String[] SMS_PROJECTION = new String[]{SMSModel.ID_1, SMSModel.THREAD_2, SMSModel.ADDRESS_3, SMSModel.DATE_4, SMSModel.DATE_SENT_5,
            SMSModel.READ_6, SMSModel.TYPE_7, SMSModel.REPLY_PATH_8, SMSModel.BODY_9, SMSModel.SUB_ID_10, SMSModel.CREATOR_11};

    private final static String[] THREAD_PROJECTION = new String[]{ThreadModel.ID_1, ThreadModel.DATE_2, ThreadModel.MESSAGE_COUNT_3, ThreadModel.SNIPPET_4,
            ThreadModel.READ_5, ThreadModel.TYPE_6};

    public static void getThreadsList(Context context, ThreadsListener threadsListener) {
        new Thread(() -> {
            List<ThreadModel> threads = getAllThreads(context);
            new Handler(Looper.getMainLooper()).post(() -> threadsListener.onComplete(threads));
        }).start();
    }

    public static List<ThreadModel> getAllThreads(Context context) {
        List<ThreadModel> threads = new ArrayList<>();
        Cursor cur = context.getContentResolver().query(URI_THREADS, THREAD_PROJECTION, null, null, "date asc");
        if (cur != null && cur.getCount() > 0) {
            cur.moveToFirst();
            do {
                if (!isBankActivationOrInvalidSMS(cur.getString(3)) || cur.getInt(2) > 0) {
                    threads.add(generateThreadModel(
                            cur.getInt(0), //id
                            cur.getLong(1), //date
                            cur.getInt(2), //count
                            cur.getString(3), //snippet
                            cur.getInt(4), //read
                            cur.getInt(5) //type
                    ));
                }
            } while (cur.moveToNext());
            cur.close();
        }
        return threads;
    }

    public static void getSortedSMSList(Context context, @Nullable String searchQuery, boolean enableFilter, SMSListListener smsQueryCompletedListener) {
        new Thread(() -> {
            List<SMSModel> smsList = searchQuery == null ? getAllSms(context, enableFilter) : searchSMS(context, searchQuery, enableFilter);
            Hashtable<Integer, SMSModel[]> tempTable = new Hashtable<>();
            for (SMSModel model : smsList) {
                if (tempTable.containsKey(model.getTHREAD())) {
                    var list = tempTable.get(model.getTHREAD());
                    if (list == null) continue;
                    var temp = new SMSModel[]{model};
                    System.arraycopy(list, 0, temp, 1, list.length - 1);
                    tempTable.put(model.getTHREAD(), temp);
                } else {
                    tempTable.put(model.getTHREAD(), new SMSModel[]{model});
                }
            }
            new Handler(Looper.getMainLooper()).post(() -> smsQueryCompletedListener.onComplete(tempTable, smsList));
        }).start();
    }

    private static List<SMSModel> getAllSms(Context context, boolean enableFilter) {
        List<SMSModel> sms_list = new ArrayList<>();
        Uri uri = Uri.parse(SMS_URI_INBOX);
        Cursor cur = context.getContentResolver().query(uri, SMS_PROJECTION, null, null, "date asc");
        if (cur != null && cur.getCount() > 0) {
            cur.moveToFirst();
            do {
                if (!enableFilter || !isBankActivationOrInvalidSMS(cur.getString(8))) { //filter UPIACT // MBACTIVATE
                    sms_list.add(generateModel(cur.getInt(0), //id
                            cur.getInt(1), //thread
                            cur.getString(2), //address
                            cur.getLong(3), //date
                            cur.getLong(4), //date sent
                            cur.getInt(5), //read status
                            cur.getInt(6), //type of message
                            cur.getString(8))); //body
                }
            } while (cur.moveToNext());
            cur.close();
        }
        return sms_list;
    }

    private static List<SMSModel> searchSMS(Context context, String query, boolean enableFilter) {
        List<SMSModel> sms_list = new ArrayList<>();
        Uri uri = Uri.parse(SMS_URI_INBOX);
        Cursor cur = context.getContentResolver().query(uri, SMS_PROJECTION, "body like '%" + query + "%' or address like '%" + query + "%'", null, "date asc");
        if (cur != null && cur.getCount() > 0) {
            cur.moveToFirst();
            do {
                if (!enableFilter || !isBankActivationOrInvalidSMS(cur.getString(8))) { //filter UPIACT // MBACTIVATE
                    sms_list.add(generateModel(cur.getInt(0), //id
                            cur.getInt(1), //thread
                            cur.getString(2), //address
                            cur.getLong(3), //date
                            cur.getLong(4), //date sent
                            cur.getInt(5), //read status
                            cur.getInt(6), //type of message
                            cur.getString(8))); //body
                }
            } while (cur.moveToNext());
            cur.close();
        }
        return sms_list;
    }

    //todo : have to add all kind of bank :(
    @SuppressWarnings("BooleanMethodIsAlwaysInverted")
    private static boolean isBankActivationOrInvalidSMS(String body) {
        return body.isBlank() ||
                body.isEmpty() ||
                body.contains("MBACTIVATE") ||
                body.contains("UPIACT") ||
                body.contains("HDFCUPI") ||
                body.contains("SBIREG") ||
                body.contains("YONOREG") ||
                body.contains("PHONEPE-SMS-VERIFY") ||
                body.equals("(null)");
    }

    public static SMSModel generateModel(int _id, int thread_, String address, long date, long date_sent, int read, int type, String body) {
        SMSModel model = new SMSModel();
        model.setID(_id);
        model.setTHREAD(thread_);
        model.setADDRESS(address);
        model.setDATE(date);
        model.setDATE_SENT(date_sent);
        model.setREAD(read);
        model.setTYPE(type);
        model.setBODY(body);
        return model;
    }

    public static ThreadModel generateThreadModel(int thread_id, long date, int count, String body, int read, int type) {
        ThreadModel model = new ThreadModel();
        model.setThread_id(thread_id);
        model.setDate(date);
        model.setMessage_count(count);
        model.setRead(read);
        model.setType(type);
        model.setSnippet(body);
        return model;
    }

    public interface ThreadsListener {
        void onComplete(List<ThreadModel> threads);
    }

    public interface SMSListListener {
        void onComplete(Hashtable<Integer, SMSModel[]> data, List<SMSModel> unSortedData);
    }
}
