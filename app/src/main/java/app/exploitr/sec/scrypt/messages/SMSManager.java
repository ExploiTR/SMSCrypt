package app.exploitr.sec.scrypt.messages;

import android.content.Context;
import android.database.Cursor;
import android.net.Uri;
import android.os.Handler;
import android.os.Looper;
import android.provider.Telephony;
import android.util.Log;

import com.google.i18n.phonenumbers.NumberParseException;
import com.google.i18n.phonenumbers.PhoneNumberUtil;
import com.google.i18n.phonenumbers.Phonenumber;

import org.jetbrains.annotations.NotNull;

import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;
import java.util.StringTokenizer;

import app.exploitr.sec.scrypt.models.SMSModel;
import app.exploitr.sec.scrypt.models.ThreadModel;
import app.exploitr.sec.scrypt.utils.Core;

public class SMSManager {
    final static String SMS_URI_INBOX = "content://sms";
    final static Uri URI_THREADS = Telephony.Threads.CONTENT_URI;

    final static String[] SMS_PROJECTION = new String[]{SMSModel.ID_1, SMSModel.THREAD_2, SMSModel.ADDRESS_3, SMSModel.DATE_4, SMSModel.DATE_SENT_5,
            SMSModel.READ_6, SMSModel.TYPE_7, SMSModel.REPLY_PATH_8, SMSModel.BODY_9, SMSModel.SUB_ID_10, SMSModel.CREATOR_11};

    private final static String[] THREAD_PROJECTION = new String[]{ThreadModel.ID_1, ThreadModel.DATE_2, ThreadModel.MESSAGE_COUNT_3, ThreadModel.SNIPPET_4,
            ThreadModel.READ_5, ThreadModel.TYPE_6};

    public static void getThreadsList(Context context, ThreadsListener threadsListener) {
        new Thread(() -> {
            List<ThreadModel> threads;
            threads = getAllThreads(context);
            new Handler(Looper.getMainLooper()).post(() -> threadsListener.onComplete(threads));
        }).start();
    }

    public static List<ThreadModel> getAllThreads(Context context) {
        List<ThreadModel> threads = new ArrayList<>();
        Cursor cur = context.getContentResolver().query(URI_THREADS, THREAD_PROJECTION, null, null, "date asc");
        if (cur != null && cur.getCount() > 0) {
            cur.moveToFirst();
            do {
//                if (!isNotBankActivationOrInvalidSMS(cur.getString(3)) || cur.getInt(2) > 0) {
//                    threads.add(generateThreadModel(
//                            cur.getInt(0), //id
//                            cur.getLong(1), //date
//                            cur.getInt(2), //count
//                            cur.getString(3), //snippet
//                            cur.getInt(4), //read
//                            cur.getInt(5) //type
//                    ));
//                }
            } while (cur.moveToNext());
            cur.close();
        }
        return threads;
    }

    public static void getSortedSMSList(Context context, @NotNull String searchQuery, boolean enableFilter,
                                        boolean ruleBasedFilter, SMSListListener smsQueryCompletedListener) {
        new Thread(() -> {
            List<SMSModel> smsList;
            try {
                smsList = searchQuery.isEmpty() ? getAllSms(context, enableFilter, ruleBasedFilter) : searchSMS(context, searchQuery, enableFilter, ruleBasedFilter);
                Hashtable<Integer, List<SMSModel>> tempTable = new Hashtable<>();
                for (SMSModel model : smsList) {
                    if (tempTable.containsKey(model.getTHREAD())) {
                        var list = tempTable.get(model.getTHREAD());
                        if (list == null) continue;
                        list.add(model);
                        tempTable.put(model.getTHREAD(), list);
                    } else {
                        ArrayList<SMSModel> sms_list = new ArrayList<>();
                        sms_list.add(model);
                        tempTable.put(model.getTHREAD(), sms_list);
                    }
                }
                new Handler(Looper.getMainLooper()).post(() -> smsQueryCompletedListener.onComplete(tempTable, smsList));
            } catch (NumberParseException e) {
                throw new RuntimeException(e);
            }
        }).start();
    }

    private static List<SMSModel> getAllSms(Context context, boolean enableFilter, boolean ruleBasedFilter) {
        List<SMSModel> sms_list = new ArrayList<>();
        Uri uri = Uri.parse(SMS_URI_INBOX);
        Cursor cur = context.getContentResolver().query(uri, SMS_PROJECTION, null, null, "date asc");
        if (cur != null && cur.getCount() > 0) {
            cur.moveToFirst();
            do {
                Log.i("SMSManager", cur.getString(2));
                if (enableFilter && isNotBankActivationOrInvalidSMS(cur.getString(2), cur.getString(8), ruleBasedFilter)) { //filter UPIACT // MBACTIVATE
                    sms_list.add(generateModel(cur.getInt(0), //id
                            cur.getInt(1), //thread
                            cur.getString(2), //address
                            cur.getLong(3), //date
                            cur.getLong(4), //date sent
                            cur.getInt(5), //read status
                            cur.getInt(6), //type of message
                            cur.getString(8))); //body
                } else if (!enableFilter) { //filter enabled but not valid
                    sms_list.add(generateModel(cur.getInt(0), //id
                            cur.getInt(1), //thread
                            cur.getString(2), //address
                            cur.getLong(3), //date
                            cur.getLong(4), //date sent
                            cur.getInt(5), //read status
                            cur.getInt(6), //type of message
                            cur.getString(8))); //body
                }
            } while (cur.moveToNext());
            cur.close();
        }
        return sms_list;
    }

    private static List<SMSModel> searchSMS(Context context, String query, boolean enableFilter, boolean ruleBasedFilter) throws NumberParseException {
        List<SMSModel> sms_list = new ArrayList<>();
        Uri uri = Uri.parse(SMS_URI_INBOX);
        Cursor cur = context.getContentResolver().query(uri, SMS_PROJECTION, "body like '%" + query + "%' or address like '%" + query + "%'", null, "date asc");
        if (cur != null && cur.getCount() > 0) {
            cur.moveToFirst();
            do {
                if (enableFilter && isNotBankActivationOrInvalidSMS(cur.getString(2), cur.getString(8), ruleBasedFilter)) { //filter UPIACT // MBACTIVATE
                    sms_list.add(generateModel(cur.getInt(0), //id
                            cur.getInt(1), //thread
                            cur.getString(2), //address
                            cur.getLong(3), //date
                            cur.getLong(4), //date sent
                            cur.getInt(5), //read status
                            cur.getInt(6), //type of message
                            cur.getString(8))); //body
                } else if (!enableFilter) { //filter enabled but not valid
                    sms_list.add(generateModel(cur.getInt(0), //id
                            cur.getInt(1), //thread
                            cur.getString(2), //address
                            cur.getLong(3), //date
                            cur.getLong(4), //date sent
                            cur.getInt(5), //read status
                            cur.getInt(6), //type of message
                            cur.getString(8))); //body
                }
            } while (cur.moveToNext());
            cur.close();
        }
        return sms_list;
    }

    private static boolean isNotBankActivationOrInvalidSMS(String address, String body, boolean ruleBasedFilter) {
        var pUtil = PhoneNumberUtil.getInstance();
        Phonenumber.PhoneNumber pNum;
        try {
            pNum = pUtil.parse(address, null);
            return ruleBasedFilter ? pUtil.isValidNumber(pNum) && isNotBankActivationSMS(body) : pUtil.isValidNumber(pNum);
        } catch (NumberParseException ignored) {
            return false;
        }
    }

    private static boolean isNotBankActivationSMS(String body) {
        if (body.isBlank() || body.isEmpty())
            return false;
        StringTokenizer tokenizer = new StringTokenizer(body, " .,?!-:;()[]{}\"\n\t");
        while (tokenizer.hasMoreTokens()) {
            String word = tokenizer.nextToken().toLowerCase(); // Convert to lowercase for case-insensitive check
            if (Core.keywords.contains(word)) {
                return false;
            }
        }
        return true;
    }

    public static SMSModel generateModel(int _id, int thread_, String address, long date, long date_sent, int read, int type, String body) {
        SMSModel model = new SMSModel();
        model.setID(_id);
        model.setTHREAD(thread_);
        model.setADDRESS(address);
        model.setDATE(date);
        model.setDATE_SENT(date_sent);
        model.setREAD(read);
        model.setTYPE(type);
        model.setBODY(body);
        return model;
    }

    public static ThreadModel generateThreadModel(int thread_id, long date, int count, String body, int read, int type) {
        ThreadModel model = new ThreadModel();
        model.setThread_id(thread_id);
        model.setDate(date);
        model.setMessage_count(count);
        model.setRead(read);
        model.setType(type);
        model.setSnippet(body);
        return model;
    }

    public interface ThreadsListener {
        void onComplete(List<ThreadModel> threads);
    }

    public interface SMSListListener {
        void onComplete(Hashtable<Integer, List<SMSModel>> data, List<SMSModel> unSortedData);
    }
}
