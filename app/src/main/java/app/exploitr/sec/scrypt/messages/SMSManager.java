package app.exploitr.sec.scrypt.messages;

import android.content.Context;
import android.database.Cursor;
import android.net.Uri;
import android.os.Handler;
import android.os.Looper;
import android.provider.Telephony;

import com.google.i18n.phonenumbers.NumberParseException;
import com.google.i18n.phonenumbers.PhoneNumberUtil;
import com.google.i18n.phonenumbers.Phonenumber;

import org.jetbrains.annotations.Nullable;

import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;
import java.util.StringTokenizer;

import app.exploitr.sec.scrypt.contacts.ContactsController;
import app.exploitr.sec.scrypt.database.SettingsDatabase;
import app.exploitr.sec.scrypt.models.SMSModel;
import app.exploitr.sec.scrypt.models.ThreadModel;
import app.exploitr.sec.scrypt.models.contact.ContactModel;
import app.exploitr.sec.scrypt.utils.Core;

public class SMSManager {
    final static String SMS_URI_INBOX = "content://sms";
    final static Uri URI_THREADS = Telephony.Threads.CONTENT_URI;

    //todo check with cursor.getColumnNames() then compare and add to avoid prod errors.
    final static String[] SMS_PROJECTION = new String[]{SMSModel.ID_1, SMSModel.THREAD_2, SMSModel.ADDRESS_3, SMSModel.DATE_4, SMSModel.DATE_SENT_5,
            SMSModel.READ_6, SMSModel.TYPE_7, SMSModel.REPLY_PATH_8, SMSModel.BODY_9, SMSModel.SUB_ID_10, SMSModel.CREATOR_11};

    private final static String[] THREAD_PROJECTION = new String[]{ThreadModel.ID_1, ThreadModel.DATE_2, ThreadModel.SNIPPET_4,
            ThreadModel.READ_5, ThreadModel.TYPE_6, Telephony.Threads.RECIPIENT_IDS};

    public static void getThreadsList(Context context, ThreadsListener threadsListener) {
        new Thread(() -> {
            List<ThreadModel> threads;
            threads = getAllThreads(context);
            new Handler(Looper.getMainLooper()).post(() -> threadsListener.onComplete(threads));
        }).start();
    }

    public static List<ThreadModel> getAllThreads(Context context) {
        List<ThreadModel> threads = new ArrayList<>();
        Cursor cur = context.getContentResolver().query(URI_THREADS, new String[]{"thread_id", "snippet", "source", "count(*)"}, null, null, "date asc");
        if (cur != null && cur.getCount() > 0) {
            cur.moveToFirst();
            do {
                if (cur.getInt(0) == 33)
                    System.out.println(cur.getInt(0) + " : " + cur.getString(1) + ":" + cur.getInt(2) + " : " + cur.getString(3));
            } while (cur.moveToNext());
            cur.close();
        }
        return threads;
    }

    public static void getSortedSMSList(Context context, @Nullable String searchQuery, SMSListListener smsQueryCompletedListener) {
        new Thread(() -> {
            var settings = SettingsDatabase.getInstance(context);
            boolean enableFilter = settings.getEnableFilter();
            boolean ruleBasedFilter = settings.getEnableRuleFilter();
            boolean contactBasedFilter = settings.getEnableContactFilter();

            List<SMSModel> smsList;
            try {
                smsList = searchQuery == null || searchQuery.isEmpty() ? getAllSms(context, enableFilter, ruleBasedFilter, contactBasedFilter) :
                        searchSMS(context, searchQuery, enableFilter, ruleBasedFilter, contactBasedFilter);
                Hashtable<Integer, List<SMSModel>> tempTable = new Hashtable<>();
                for (SMSModel model : smsList) {
                    if (tempTable.containsKey(model.getTHREAD())) {
                        var list = tempTable.get(model.getTHREAD());
                        if (list == null) continue;
                        list.add(model);
                        tempTable.put(model.getTHREAD(), list);
                    } else {
                        ArrayList<SMSModel> sms_list = new ArrayList<>();
                        sms_list.add(model);
                        tempTable.put(model.getTHREAD(), sms_list);
                    }
                }
                new Handler(Looper.getMainLooper()).post(() -> smsQueryCompletedListener.onComplete(tempTable, smsList));
            } catch (NumberParseException e) {
                throw new RuntimeException(e);
            }
        }).start();
    }

    private static List<SMSModel> getAllSms(Context context, boolean enableFilter, boolean ruleBasedFilter, boolean contactBasedFilter) {
        List<SMSModel> sms_list = new ArrayList<>();
        Uri uri = Uri.parse(SMS_URI_INBOX);
        Cursor cur = context.getContentResolver().query(uri, SMS_PROJECTION, null, null, "date desc");
        if (cur != null && cur.getCount() > 0) {
            cur.moveToFirst();
            do {
                var contact = ContactsController.searchContactE164(cur.getString(2));
                if (enableFilter) {
                    if (isNotBankActivationOrInvalidSMS(cur.getString(2), cur.getString(8), ruleBasedFilter)) {
                        if (!(contact == null && contactBasedFilter)) {
                            sms_list.add(generateModel(cur.getInt(0), //id
                                    cur.getInt(1), //thread
                                    cur.getString(2), //address
                                    cur.getLong(3), //date
                                    cur.getLong(4), //date sent
                                    cur.getInt(5), //read status
                                    cur.getInt(6), //type of message
                                    cur.getString(8), contact)); //body
                        }
                    }
                } else {
                    //filter enabled but not valid
                    sms_list.add(generateModel(cur.getInt(0), //id
                            cur.getInt(1), //thread
                            cur.getString(2), //address
                            cur.getLong(3), //date
                            cur.getLong(4), //date sent
                            cur.getInt(5), //read status
                            cur.getInt(6), //type of message
                            cur.getString(8), contact)); //body
                }
            } while (cur.moveToNext());
            cur.close();
        }
        return sms_list;
    }

    private static List<SMSModel> searchSMS(Context context, String query, boolean enableFilter, boolean ruleBasedFilter, boolean contactBasedFilter)
            throws NumberParseException {
        List<SMSModel> sms_list = new ArrayList<>();
        Uri uri = Uri.parse(SMS_URI_INBOX);
        Cursor cur = context.getContentResolver().query(uri, SMS_PROJECTION, "body like '%" + query + "%' or address like '%" + query + "%'", null, "date desc");
        if (cur != null && cur.getCount() > 0) {
            var contact = ContactsController.searchContactE164(cur.getString(2));
            cur.moveToFirst();
            do {
                if (enableFilter) {
                    if (isNotBankActivationOrInvalidSMS(cur.getString(2), cur.getString(8), ruleBasedFilter)) {
                        if (!(contact == null && contactBasedFilter)) {
                            sms_list.add(generateModel(cur.getInt(0), //id
                                    cur.getInt(1), //thread
                                    cur.getString(2), //address
                                    cur.getLong(3), //date
                                    cur.getLong(4), //date sent
                                    cur.getInt(5), //read status
                                    cur.getInt(6), //type of message
                                    cur.getString(8), contact)); //body
                        }
                    }
                } else {
                    //filter enabled but not valid
                    sms_list.add(generateModel(cur.getInt(0), //id
                            cur.getInt(1), //thread
                            cur.getString(2), //address
                            cur.getLong(3), //date
                            cur.getLong(4), //date sent
                            cur.getInt(5), //read status
                            cur.getInt(6), //type of message
                            cur.getString(8), contact)); //body
                }
            } while (cur.moveToNext());
            cur.close();
        }
        return sms_list;
    }

    private static boolean isNotBankActivationOrInvalidSMS(String address, String body, boolean ruleBasedFilter) {
        var pUtil = PhoneNumberUtil.getInstance();
        Phonenumber.PhoneNumber pNum;
        try {
            pNum = pUtil.parse(address, null);
            return ruleBasedFilter ? pUtil.isValidNumber(pNum) && isNotBankActivationSMS(body) : pUtil.isValidNumber(pNum);
        } catch (NumberParseException ignored) {
            return false;
        }
    }

    private static boolean isNotBankActivationSMS(String body) {
        if (body.isBlank() || body.isEmpty())
            return false;
        StringTokenizer tokenizer = new StringTokenizer(body, " .,?!-:;()[]{}\"\n\t");
        while (tokenizer.hasMoreTokens()) {
            String word = tokenizer.nextToken().toLowerCase(); // Convert to lowercase for case-insensitive check
            if (Core.keywords.contains(word)) {
                return false;
            }
        }
        return true;
    }

    public static SMSModel generateModel(int _id, int thread_, String address, long date, long date_sent, int read, int type, String body,
                                         @Nullable ContactModel custom_contact_name) {
        SMSModel model = new SMSModel();
        model.setID(_id);
        model.setTHREAD(thread_);
        model.setADDRESS(address);
        model.setDATE(date);
        model.setDATE_SENT(date_sent);
        model.setREAD(read);
        model.setTYPE(type);
        model.setBODY(body);
        model.setContact(custom_contact_name);
        return model;
    }

    public static ThreadModel generateThreadModel(int thread_id, long date, int count, String body, int read, int type) {
        ThreadModel model = new ThreadModel();
        model.setThread_id(thread_id);
        model.setDate(date);
        model.setMessage_count(count);
        model.setRead(read);
        model.setType(type);
        model.setSnippet(body);
        return model;
    }

    public interface ThreadsListener {
        void onComplete(List<ThreadModel> threads);
    }

    public interface SMSListListener {
        void onComplete(Hashtable<Integer, List<SMSModel>> data, List<SMSModel> unSortedData);
    }
}
